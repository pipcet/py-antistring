py-antistring
=============

make  print "hi there" - "there"  print "hi "

This is a very crude implementation of the free group generated by all
strings. That group contains strings, anti-strings, and concatenations
of strings and antistrings, with letters and their antiletters
cancelling out.

Put another way, if we think of string concatenation as addition, what
the free group adds over the free monoid (the set of normal strings)
is subtraction: ("xyz" - "z") is valid and evaluates to "xy". ("xyz" -
"x") is also valid, but doesn't evaluate to "yz" (-"x" + "xyz" does,
though)

This is very hackish because Python doesn't appear to have a simple
way to overload string constants, like Perl's
overload::constant. Instead, we walk our syntax tree and replace
string constants with function calls as we go along. That's not a
perfect solution, but it actually allows us to create a variant of
standard Python in essentially no time, and that's pretty cool.

Some mathematicians object to using the + operator for things like
string concatenation, because in mathematics, + is almost always
commutative (that means a+b is always equal to b+a, which isn't true
for strings). However, there is at least one exception, the addition
of ordinal numbers, where ω+1 ≠ 1+ω, and I think strings should also
be an exception.

Is this useful in practice? At least in my code, a recurring pattern
is stripping a known prefix from a string's beginning or end. You can
use string slicing, but that's error-prone if you forget to actually
check the prefix or suffix was there. You can also use regular
expressions, but they're regular expressions. I think using -prefix +
x in string context, and knowing you'll get an exception if x doesn't
actually begin with prefix, is best.

This implementation is horribly slow and not very well-tested, but
simple enough I believe it might work.

I'm very likely not the first person to do this, so this is mostly an
educational exercise.
